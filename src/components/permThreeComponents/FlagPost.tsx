/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import { Sphere, useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useFrame } from '@react-three/fiber'
import { Vector3 } from 'three'
import { RigidBodyProps } from '@react-three/rapier'
import { FC } from 'react'

type GLTFResult = GLTF & {
  nodes: {
    Cylinder: THREE.Mesh
    Circle: THREE.Mesh
  }
  materials: {
    ['Material.002']: THREE.MeshPhysicalMaterial
    ['Material.001']: THREE.MeshStandardMaterial
  }
}

/**
 * Props for the FlagPost component.
 *
 * @typedef {Object} FlagPostProps
 * @extends RigidBodyProps
 * @property {Vector3} initialPos - The initial position of the flag post.
 */
interface FlagPostProps extends RigidBodyProps {
  initialPos: Vector3
}

/**
 * FlagPost component.
 *
 * This returns a FlagPost Model that can move when an object "golf-ball" is nearby.
 *
 * @param {FlagPostProps} Props - The properties for the FlagPost component.
 * @returns {JSX.Element} The rendered FlagPost component.
 */
export const FlagPost: FC<FlagPostProps> = ({ initialPos, ...props }) => {
  useFrame(({ scene }) => {
    const golfBall = scene.getObjectByName('golf-ball')
    const flagPostBoundary = scene.getObjectByName('flag-post-raise-boundary')
    const wholeFlag = scene.getObjectByName('total-flag')

    if (golfBall?.position.x && flagPostBoundary && wholeFlag) {
      const golfBallPos = golfBall.position

      const flagPostBoundaryPos = wholeFlag.position

      const flagPostBoundaryIntersect = new Vector3(0, 0, 0)
      flagPostBoundaryIntersect.subVectors(flagPostBoundaryPos, golfBallPos)
      const distance = Math.sqrt(
        flagPostBoundaryIntersect.x * flagPostBoundaryIntersect.x +
          flagPostBoundaryIntersect.y * flagPostBoundaryIntersect.y +
          flagPostBoundaryIntersect.z * flagPostBoundaryIntersect.z
      )

      if (distance < 6 && wholeFlag) {
        const newRaisedPosition = new Vector3()
        const vectorToAdd = new Vector3(0, 3, 0)
        newRaisedPosition.addVectors(flagPostBoundaryPos, vectorToAdd)
        wholeFlag.position.lerp(newRaisedPosition, 0.05)
      }
      if (distance > 4 && wholeFlag) {
        const newRaisedPosition = new Vector3()
        const vectorToAdd = new Vector3(0, -1.5, 0)
        newRaisedPosition.addVectors(flagPostBoundaryPos, vectorToAdd)
        wholeFlag.position.lerp(initialPos, 0.02)
      }
    }
  })

  const { nodes, materials } = useGLTF('/HoleFlagPole.glb') as GLTFResult
  return (
    <>
      <group {...props} dispose={null} name='total-flag' position={initialPos}>
        <Sphere scale={[3, 3, 3]} name='flag-post-raise-boundary' visible={false} />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cylinder.geometry}
          material={materials['Material.002']}
          position={[0, 4, 0]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Circle.geometry}
          material={materials['Material.001']}
          position={[0, 6.741, -1.497]}
          rotation={[0, 0, -Math.PI / 2]}
          scale={[0.581, 1, 1]}
        />
      </group>
    </>
  )
}

useGLTF.preload('/holeFlagMod.glb')
